import random
import timeit

list = range(1,100)
random.shuffle(list)

### Bubble Sort w/ complexity O(n^2) in the worst case.  Bubble Sort works
### by examining the first two numbers in the list, i and i+1=j, and comparing
### their values.  If i<j, then the numbers remain in their positions and
### the algorithm continues on to the second set of numbers in the list (indexes 1 and 2).
### If i>j, then the positions of i and j are exchanged, and the algorithm continues on
### to the second set of numbers in the current form of the list, which are
### the first and third numbers of the original list.  This process continues
### until the algorithm reaches the final pair of numbers and performs
### the comparison.

def bubblesort(list_numbers):
	for i in range(len(list_numbers)):
		for j in range(i+1, len(list_numbers)):
			if list_numbers[i]>list_numbers[j]:
				list_numbers[i], list_numbers[j] = list_numbers[j], list_numbers[i]
	return list_numbers

### Mergesort w/ complexity O(n log n).  Mergesort works by dividing the original
### unsorted list into sublists, each of which contain one element--and thus
### all of the sublists are internally sorted.  Then, the algorithm merges
### these sublists of equal size, and sorts the list elements as the merges
### is executed; thus, in the first iteration of the 
### algorithm, it merges all lists of length 1 with other lists of length 1
### such that all lists are then of length 2.  The process repeats until
### only 1 list exists.

### The implementation of the algorithm, as coded, works as follows.
### A mergesort function is created, which takes a list of numbers and
### recursively breaks that list into smaller lists by calling the 
### function again and breaking each given list in half.  These calls
### are stacked until the lists are all of  length one, such that each
### number is in its own list (i.e. sorted in its own list), and then
### the stacked calls begin to return those smaller lists and use
### those smaller lists as inputs to the merge function.

### The merge function takes two lists generated by the mergesort's 
### splitting process, and sorts the two lists into one list.  First, merge
### compares the first items in each list, and takes the smaller values
### and appends it to the beginning of a new list.  Then, the
### index of the list from which an item was appended is increased
### by one, and the process repeats.  Once all items from one of the lists
### has been appended to the new list, the function extends the new
### list by adding all remaining items in the other list.  Then,
### the function returns the new list, created by merging the two smaller
### lists.

### As the merge function merges sets of smaller lists, the stacked calls
### are fulfilled in the opposite direction in which they were created,
### until ultimately the two largest sublists are merged with the merge
### function and mergesort eventually returns the fully sorted list.

def mergesort(list_numbers):
	if len(list_numbers) < 2:
		return list_numbers
	midpoint = len(list_numbers)/2
	a = mergesort(list_numbers[:midpoint])
	b = mergesort(list_numbers[midpoint:])
	return merge(a,b)
	
def merge(a,b):
	new_list =[]
	i=0
	j=0
	list_lengths = len(a) + len(b)
	while len(new_list) < list_lengths:
		if a[i] < b[j]:
			new_list.append(a[i])
			i += 1
		else:
			new_list.append(b[j])
			j += 1
		#if i == len(a) or j == len(b):
		#	new_list.extend(a[i:] or b[j:])
		if i == len(a) or j == len(b):
			if i == len(a):
				new_list.extend(b[j:])
			if j == len(b):
				new_list.extend(a[i:])
	return new_list
	
#####################

### Both of the simulation algoritms work as follows.  The user inputs
### the maximum sample size on which they want to run the algorithm,
### and the number of iterations for which they want to run the algorithm
### for each sample size (in order to obtain a more unbiased estimate of
### run time).  The algoritms generate a list of sample lists for each
### sample size desired.  Then, the algorithms select each of those
### sample lists, and, for the number of iterations desired, measures
### the run time of the algorithm on the randomized sample list.  Then,
### we obtain the mean run time for each list over the number of iterations
### performed on that list, and append it to the list of run times
### which we created outside of the function.  Lastly, we also create
### a list of sample sizes by appending to a list outside of the function.
### Our output is a list of the sample sizes analyzed, and a list of
### the mean run times obtained for each of those sample sizes.  We
### can then plot the two sets of run times and sample sizes to
### observe their run time performance.

run_times_ms = []
sample_size_ms = []

def mergesort_sim(max_samp_size,num_iter_per=100):
	samples = []
	for i in range(0,max_samp_size):
		samp_size = range(0,i)
		samples.append(samp_size)
	for i in range(0,len(samples)):
		list = samples[i]
		times = []
		for i in range(0,num_iter_per):
			random.shuffle(list)
			start = timeit.default_timer()
			mergesort(list)
			stop = timeit.default_timer()
			execute_time = stop-start
			times.append(execute_time)
		mean_time = numpy.mean(times)
		run_times_ms.append(mean_time)
	for i in range(0,len(samples)):
		size_sample = len(samples[i])
		sample_size_ms.append(size_sample)

run_times_bs = []
sample_size_bs = []

def bubblesort_sim(max_samp_size,num_iter_per=100):
	samples = []
	for i in range(0,max_samp_size):
		samp_size = range(0,i)
		samples.append(samp_size)
	for i in range(0,len(samples)):
		list = samples[i]
		times = []
		for i in range(0,num_iter_per):
			random.shuffle(list)
			start = timeit.default_timer()
			bubblesort(list)
			stop = timeit.default_timer()
			execute_time = stop-start
			times.append(execute_time)
		mean_time = numpy.mean(times)
		run_times_bs.append(mean_time)
	for i in range(0,len(samples)):
		size_sample = len(samples[i])
		sample_size_bs.append(size_sample)	
			
		

plt.plot(sample_size_bs,run_times_bs,label="Bubble Sort")
plt.plot(sample_size_ms,run_times_ms,label="Merge Sort")

plt.title("Comparative Run Times of Sorting Algorithms")
plt.ylabel("Run Time")
plt.xlabel("Size of Set to Sort")

plt.legend(loc=2)

plt.show()